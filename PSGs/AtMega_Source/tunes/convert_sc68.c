/*
 * Converts a regdump generated by sc68 to the text regdump format used by my code
 * 
 * sc68 --ym-engine=dump -qqqn <sndh-file>
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <argp.h>

static struct argp_option options[] = {
	{ "if", 'i', "FILE", 0, "Input file." },
	{ "of", 'o', "FILE", 0, "Output file." },
	{ 0 }
};

struct arguments {
	char *input_file;
	char *output_file;
};

static error_t parse_opt(int key, char *arg, struct argp_state *state) {
	struct arguments *arguments = state->input;
	
	switch(key) {
		case 'i':
			arguments->input_file = arg;
			break;
		case 'o':
			arguments->output_file = arg;
			break;
		default:
			return ARGP_ERR_UNKNOWN;
	}
	return 0;
}

static struct argp argp = { options, parse_opt, 0, 0 };

int main(int argc, char **argv) {
	struct arguments arguments;
	arguments.output_file = 0;
	arguments.input_file = 0;
	argp_parse(&argp, argc, argv, 0, 0, &arguments);
	
	if(arguments.output_file == 0 || arguments.input_file == 0) {
		printf("Missing required arguments\n");
		return 1;
	}
	
	FILE *infile = fopen(arguments.input_file, "rb");
	FILE *outfile = fopen(arguments.output_file, "wb");
	
	if(!infile || !outfile) {
		printf("Error opening file\n");
		if(infile) fclose(infile);
		if(outfile) fclose(outfile);
		return 1;
	}
	
	long fpos = 0;
	char lineBuffer[128];
	char end = 0;
	long time;
	int regvals[14];
	int prev_regvals[14];
	for(int i = 0; i < 14; i++) prev_regvals[i] = -1;
	while(end == 0) {
		for(int i = 0; i < 128; i++) lineBuffer[i] = 0;
		fread(lineBuffer, 1, 128, infile);
		int lineEnd = 0;
		for(int i = 0; i < 128; i++) {
			fpos++;
			if(lineBuffer[i] == '\n') {
				lineBuffer[i] = 0;
				fseek(infile, fpos, SEEK_SET);
				break;
			}else if(lineBuffer[i] == 0) {
				end = 1;
			}
		}
		if(strlen(lineBuffer) == 0) break;
		char* parts[3];
		parts[0] = lineBuffer;
		parts[1] = 0;
		parts[2] = 0;
		for(int i = 0; i < 128; i++) {
			if(lineBuffer[i] == ' ') {
				lineBuffer[i] = 0;
				if(parts[1]) {
					parts[2] = lineBuffer + i + 1;
					break;
				}else parts[1] = lineBuffer + i + 1;
			}else if(lineBuffer[i] == 0) {
				printf("Invalid formating on line \"%s\"\n", lineBuffer);
				fclose(outfile);
				fclose(infile);
				return 1;
			}
		}
		
		time = strtol(parts[1], NULL, 16);
		time /= 2;
		
		for(int i = 0; i < 14; i++) {
			if(parts[2][2] != '-' && parts[2][2] != 0) {
				printf("Invalid formatting\n");
				fclose(outfile);
				fclose(infile);
				return 1;
			}
			parts[2][2] = 0;
			if(strcmp(parts[2], "..") == 0) {
				regvals[i] = prev_regvals[i];
			}else {
				regvals[i] = (int)strtol(parts[2], NULL, 16);
			}
			parts[2] += 3;
		}
		
		for(int i = 0; i < 14; i++) {
			if(regvals[i] != prev_regvals[i]) {
				sprintf(lineBuffer, "%ld-%d-%d\n", time, i, regvals[i]);
				fwrite(lineBuffer, 1, strlen(lineBuffer), outfile);
			}
			prev_regvals[i] = regvals[i];
		}
	}
}
